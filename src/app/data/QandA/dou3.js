export const dou3 = [
  {
    question: 'Які ви знаєте проблеми, баги та вузькі місця у Node.js?',
    answer:
      "Проблеми та баги у Node.js: Можливість блокування одним завданням інших, витоки пам'яті, нестабільність деяких API тощо.",
  },
  {
    question:
      'Які ви знаєте вбудовані засоби серіалізації у Node.js, аналогічні до JSON, але для бінарної серіалізації?',
    answer:
      'Вбудовані засоби серіалізації: Buffer та TypedArray для бінарної серіалізації.',
  },
  {
    question:
      'Чому Node.js не однопотоковий? Доведіть, що він ніколи не був однопотоковим?',
    answer:
      'Node.js не однопотоковий, бо він використовує потоки та інші механізми для паралельної обробки завдань.',
  },
  {
    question: 'Чим замінити deprecated: fs.exists?',
    answer: 'Використовуйте fs.promises.access або fs.promises.stat.',
  },
  {
    question:
      'Що таке back pressure для стримів? Що спричинила б його відсутність?',
    answer:
      "Це механізм управління потоком даних для запобігання переповнення буфера. Його відсутність може призвести до витоків пам'яті та інших проблем.",
  },
  {
    question: 'Що таке MessagePort і BroadcastChannel?',
    answer:
      'Це механізми для обміну повідомленнями між різними контекстами, такими як робочі потоки та вкладені iframes.',
  },
  {
    question: 'Чим відрізняються fs.stat, fs.fstat, fs.lstat?',
    answer:
      'Вони використовуються для отримання інформації про файл, але fs.fstat працює з файловим дескриптором, а не зі шляхом, і fs.lstat враховує символьні посилання.',
  },
  {
    question: 'Як пов’язані node:async_hooks і AsyncLocalStorage?',
    answer:
      'async_hooks дозволяє стежити за життєвим циклом асинхронних операцій, а AsyncLocalStorage дозволяє зберігати контекст між асинхронними функціями.',
  },
  {
    question: 'Чого не вистачає у ESM, що підтримується у CJS?',
    answer:
      'ESM надає модульну систему, але вимагає зовнішній трансляції для оптимізації V8.',
  },
  {
    question:
      'Як стежити за змінами файлів і директорій на диску? Які з цим можуть виникати проблеми?',
    answer:
      'Використовуйте fs.watch або chokidar. Проблеми можуть включати накладання подій та витоки ресурсів.',
  },
  {
    question: 'Що можна робити за допомогою node:vm?',
    answer:
      'Node.js VM модуль дозволяє виконувати код в ізольованих середовищах.',
  },
  {
    question:
      'Як захистити SharedArrayBuffer від запису з різних worker_threads?',
    answer: 'Використовуйте WebAssembly або інші механізми контролю доступу.',
  },
  {
    question:
      'Доведіть, що будь-який модуль у Node.js при завантаженні огортається у функцію і створює замикання?',
    answer:
      'Модуль у Node.js завжди огортається у функцію для створення замикання.',
  },
  {
    question:
      'Де використовують патерн Revealing constructor (відкритий конструктор)?',
    answer: 'Використовується для відкритого доступу до конструктора.',
  },
  {
    question:
      'Як зробити перевизначення write для екземпляру Writable без створення класу спадкоємця?',
    answer: 'Можна використовувати Writable.prototype._write.',
  },
  {
    question:
      'У чому причина повільності викликів з JavaScript коду до аддонів на C, C++ чи під’єднаних через N-API?',
    answer:
      "Це може бути пов'язано з накладанням перекладу між JavaScript та C/C++.",
  },
  {
    question: 'Навіщо потрібен WASI та які можливості він дає?',
    answer:
      'WebAssembly System Interface - стандарт для доступу до системних ресурсів в WebAssembly.',
  },
  {
    question: 'Для чого використовують new Error.captureStackTrace?',
    answer:
      'Використовується для захоплення стеку виклику для поточного виключення.',
  },
  {
    question:
      'Які ви знаєте deprecated API та якою є стратегія їх виведення з використання?',
    answer:
      'Призначена стратегія виведення deprecated API залежить від розробників, але зазвичай вони позначаються як deprecated та рекомендується використовувати альтернативу.',
  },
  {
    question:
      'Чому важливо виконувати правило eslint: consistent-return з огляду на оптимізацію v8?',
    answer:
      'Це правило допомагає оптимізувати код для V8 шляхом забезпечення однакового типу повернення з функцій.',
  },
  {
    question:
      'Чому потрібно додавати префікс node при завантаженні вбудованих модулів?',
    answer:
      'Префікс "node:" додають до імен вбудованих модулів, щоб відрізняти їх від інших модулів та пакетів, що встановлюються ззовні. Це допомагає уникнути конфліктів імен та однозначно вказати, що модуль є частиною Node.js.',
  },
  {
    question:
      'Що можна зробити за допомогою for await з request: IncomingMessage?',
    answer:
      'За допомогою for await з request: IncomingMessage можна асинхронно читати дані з вхідного потоку (request) в режимі, який підтримує асинхронну ітерацію, наприклад, у циклі for await...of. Це корисно при отриманні потокових даних, наприклад, при обробці HTTP-запитів.',
  },
  {
    question:
      'Як скопіювати теку з вкладеними файлами та іншими теками за допомогою node:fs?',
    answer:
      'Для копіювання теки з вкладеними файлами і іншими теками використовують модуль node:fs разом із функцією fs-extra.copy(). Цей модуль надає додаткові функції для операцій з файлами та теками.',
  },
  {
    question:
      'Навіщо використовують AbortController? В яких API він підтримується?',
    answer:
      'AbortController використовується для скасування асинхронних операцій, таких як HTTP-запити, коли потрібно зупинити їх виконання. Він підтримується в браузерному API Fetch і в Node.js з пакету node:abort-controller.',
  },
  {
    question: 'Чим сучасним замінити node:domain API?',
    answer:
      'Node.js більше не рекомендує використовувати модуль node:domain. Замість нього, для обробки помилок та винятків рекомендується використовувати механізми Promise та async/await.',
  },
  {
    question: 'Яке API реалізує nodejs/undici?',
    answer:
      'Модуль nodejs/undici реалізує HTTP-клієнт для Node.js, який працює у низькорівневому режимі та дозволяє ефективно виконувати багато запитів одночасно.',
  },
  {
    question:
      'Коли ми можемо використовувати синхронні версії операцій з файлами з node:fs замість асинхронних? На що звертати увагу, ухвалюючи таке рішення?',
    answer:
      'Синхронні операції з файлами з node:fs варто використовувати тільки тоді, коли точно відомо, що вони не заблокують головний потік виконання. У інших випадках рекомендується використовувати асинхронні операції для забезпечення ефективності та відмовостійкості.',
  },
  {
    question:
      'Наведіть найкращі практики для обробки помилок в асинхронному коді.',
    answer:
      "Найкращі практики для обробки помилок в асинхронному коді включають використання try/catch, обробку помилок за допомогою catch для об'єктів Promise, запис інформації про помилку та логування. Рекомендується також використовувати бібліотеки для обробки та логування помилок, наприклад, Sentry або Winston.",
  },
  {
    question:
      'Як у проєктах на Node.js можуть з’явитися вразливості з (на вибір): XSS, Path traversal, SQLI, CSRF? Як від них захищатися?',
    answer:
      "Вразливості, такі як XSS, Path traversal, SQLI і CSRF, можуть з'явитися у проектах на Node.js через некоректну обробку вхідних даних та недостатню валідацію. Для захисту від них важливо правильно валідувати та екранувати дані, використовувати параметризовані запити до бази даних, налаштовувати CORS і використовувати бібліотеки для обробки сесій та аутентифікації.",
  },
  {
    question: 'Як можливі race conditions при асинхронному програмуванні?',
    answer:
      'Race conditions можуть виникнути при асинхронному програмуванні, коли два або більше асинхронні потоки спробують змінити спільний ресурс без синхронізації. Це може призвести до непередбачуваного стану програми. Щоб уникнути race conditions, можна використовувати механізми блокування або обіцянки (Promises) разом з async/await.',
  },
  {
    question:
      'Які є плюси та мінуси розділення коду на .js та окремо тайпінги .d.ts?',
    answer:
      'Розділення коду на .js та окремо .d.ts (типи TypeScript) дозволяє відокремити логіку програми від її типізації. Плюси включають полегшення розвитку та рефакторингу, покращення автодокументації та можливість робити статичний аналіз коду. Однак це може призвести до збільшення обсягу коду та підтримуваної інфраструктури.',
  },
  {
    question:
      'Наведіть кілька типових патернів проєктування з GoF і приклади їхнього використання у Node.js.',
    answer:
      'Патерни проєктування з GoF, такі як Singleton, Factory, Observer, можуть бути використані в Node.js для поліпшення архітектури та розширення можливостей коду. Наприклад, паттерн Observer може використовуватися для реалізації спостерігачів подій (Event Emitters) в Node.js.',
  },
  {
    question: 'Який паттерн з GoF реалізує EventEmitter?',
    answer:
      "EventEmitter реалізує паттерн Observer з GoF, дозволяючи об'єктам слідкувати за змінами стану та сповіщати про ці зміни інші об'єкти.",
  },
  {
    question: 'У чому полягає проблема товстих контролерів?',
    answer:
      'Проблема товстих контролерів полягає у тому, що всі логіка та бізнес-логіка зосереджені в одному контролері, що призводить до нечитабельного та важко підтримуваного коду. Рекомендується розділювати логіку на кілька менших функціональних блоків або класів.',
  },
  {
    question:
      'Наведіть приклади протікання абстракцій у типових системах на базі Node.js.',
    answer:
      'Протікання абстракцій в системах на базі Node.js може виникнути, коли використовуються абстракції, які не враховують специфіку Node.js або зайво абстрагуються від реального середовища виконання.',
  },
  {
    question:
      'Як можна створити singleton за допомогою системи модульності у Node.js?',
    answer:
      'Створення singleton у Node.js можна реалізувати за допомогою замикань, експорту одного екземпляра класу або використанням модульності.',
  },
  {
    question: 'Наведіть приклад патерну adapter з вбудованих бібліотек.',
    answer:
      "Патерн адаптера (Adapter pattern) використовується для конвертації інтерфейсу одного об'єкта в інший, щоб забезпечити сумісність. Прикладом може бути адаптація інтерфейсу для взаємодії з різними базами даних або зовнішніми API.",
  },
  {
    question:
      'Для чого нам потрібні такі поля Error: error.cause, error.code, error.message, error.stack?',
    answer:
      "Поля error.cause, error.code, error.message і error.stack в Error об'єктах використовуються для надання інформації про помилку. Наприклад, error.message містить текстовий опис помилки, error.stack містить стек викликів, де виникла помилка, а error.code може містити код помилки, який може бути використаний для обробки помилок у програмі. error.cause може містити посилання на іншу помилку, якщо ця помилка була викликана іншою помилкою.",
  },
]
