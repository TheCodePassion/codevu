import Header from '@/app/components/Header'
export default function Patterns() {
  return (
    <>
      <Header />
      <div className="flex justify-center  h-screen bg-gray-100">
        <div className="bg-white shadow-md p-6 rounded-lg">
          <h1>
            {' '}
            <a
              href="https://www.amazon.com/Head-First-Design-Patterns-Object-Oriented-dp-149207800X/dp/149207800X/ref=dp_ob_title_bk"
              target="_blank"
              className="text-blue-500 hover:underline"
            >
              Нотатка зроблена за цією книгою
            </a>
          </h1>
          <p className="text-gray-700">
            Паттерн Стратегії Визначте аспекти, які можуть змінюватися, та
            інкапсулюйте їх, щоб вони не впливали на решту коду. Визначте
            аспекти програми, які можуть змінюватися, і виділіть їх від тих, які
            завжди залишаються незмінними. Усі паттерни надають можливість
            змінювати певну частину системи незалежно від інших частин.
            Програмуйте на рівні інтерфейсу, а не на рівні реалізації. Перевагу
            надавайте композиції перед успадкуванням. Паттерн Стратегії визначає
            родину алгоритмів, інкапсулює кожен з них і робить їх
            взаємозамінними. Це дозволяє змінювати алгоритми незалежно від їх
            використання на стороні клієнта.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерн Спостерігача Паттерн Спостерігача визначає
            &#34;один-до-багатьох&#34; відношення між об&#39;єктами, де зміна
            стану одного об&#39;єкта автоматично повідомляє і оновлює всі
            залежні об&#39;єкти. Прагніть до слабкого зв&#39;язку між
            взаємодіючими об&#39;єктами.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерн Декоратора Паттерн Декоратора розширює можливості класу.
            Класи повинні бути відкритими для розширення, але закритими для
            змін. Паттерн Декоратора динамічно додає нові функціональності
            об&#39;єкту і надає гнучку альтернативу успадкуванню для розширення
            функціональності.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерн Фабрики Фабричний метод відповідає за створення об&#39;єктів
            і інкапсулює цю операцію у підкласі. Таким чином, код клієнта в
            суперкласі відокремлюється від коду створення об&#39;єкта в
            підкласі. Паттерн Фабричного методу визначає інтерфейс для створення
            об&#39;єкта, але дозволяє підкласам вирішувати, який клас
            створювати. Отже, Фабричний метод делегує операцію створення
            підкласам. Код повинен залежати від абстракцій, а не від конкретних
            класів. Абстрактний паттерн Фабрики надає інтерфейс для створення
            родини пов&#39;язаних або залежних об&#39;єктів без вказівки їх
            конкретних класів.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерн Одинака Паттерн Одинака забезпечує наявність лише одного
            екземпляра класу і надає глобальну точку доступу до цього
            екземпляра.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерн Команди Паттерн Команди інкапсулює запит як об&#39;єкт, що
            дозволяє параметризувати клієнтів різними запитами, створювати черги
            або реєструвати запити і підтримувати відмінні операції.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерни Адаптера і Фасаду Паттерн Адаптера перетворює інтерфейс
            класу в інший інтерфейс, який очікують клієнти. Адаптер дозволяє
            класам працювати разом, коли це було б неможливо через несумісні
            інтерфейси. Паттерн Фасаду надає єдиний інтерфейс для групи
            інтерфейсів у підсистемі. Фасад визначає вищорівневий інтерфейс, що
            спрощує використання підсистеми. Принцип Найменшого Знання:
            Комунікуйте лише з близькими друзями. Паттерн Відшаблонного Методу
            визначає скелет алгоритму в методі, відкладаючи деякі кроки для
            підкласів. Підкласи можуть перевизначити певні частини алгоритму, не
            змінюючи його структуру. Не дзвоніть нам, ми вам зателефонуємо.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерни Ітератора і Композиту Паттерн Ітератора надає механізм
            послідовного ітерування елементів колекції без розкриття її
            внутрішнього представлення. Клас повинен мати лише одну причину для
            зміни. Паттерн Композиту складає об&#39;єкти в деревоподібні
            структури для представлення ієрархій частина-ціле. Композит дозволяє
            клієнтам виконувати однорідні операції над окремими об&#39;єктами та
            колекціями об&#39;єктів.
          </p>
          <br></br>
          <p className="text-gray-700">
            Паттерн Стану Паттерн Стану управляє поведінкою об&#39;єкта при
            зміні його внутрішнього стану. Зовні, здається, що об&#39;єкт змінює
            свій клас.
          </p>
          <br></br>
          <p className="text-gray-700 pd-10">
            {' '}
            Паттерн Проксі Паттерн Проксі надає об&#39;єкту-заміснику контроль
            доступу до іншого об&#39;єкта.
          </p>
          <br></br>
        </div>
      </div>
    </>
  )
}
